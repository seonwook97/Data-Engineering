# RDBMS 구조와 동작 방식

1. [RDBMS Architecture](#1-rdbms-architecture)
2. [MySQL Architecture](#2-mysql-architecture)

---

## 1. RDBMS Architecture

### 1-1. RDBMS의 아키텍처와 구성요소

#### 1-1-1. Overview
- 참고: https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf

![image](https://user-images.githubusercontent.com/92377162/233919075-e885c58c-de85-458a-9106-4fb98fec8e8a.png)

#### 1-1-2. Client Communication Manager
- 외부의 Client 에서 접속하고, 명령을 전달할 수 있는 통로. 그리고 그 자원의 관리.
- Client 로부터의 연결을 받는다
    - 연결을 맺기 위한 인증, 보안 등의 프로세스를 처리한다.
- Client의 연결의 상태를 관리한다. (session)
- SQL의 실행 결과를 응답한다.

#### 1-1-3. Process Manager
- RDBMS에서 필요한 자원을 관리, 주로 프로세스/스레드의 전용, 스케줄링, 할당 등을 관리.
- Client에서 요청와서 연결을 맺으면 스레드에 할당된다. 이 때 Process Manager 는 Client connection pool 에서 유휴 스레드를 꺼내서 할당한다.
- 뿐만 아니라 read, write 등의 전용 스레드 풀도 따로 관리해서, 특정 작업의 부하나 병목 때문에 다른 작업을 할 자원이 부족한 일이 없게 한다.
- 실행을 즉시 할지, 지연해서 할지 등의 결정도 할 수 있다.

#### 1-1-4. Relational Query Processor
- Client 로부터 전달된 쿼리의 해석과 실행 계획을 담당.
- Query Parser가 Query 를 파싱한다.
- 접속한 유저가 해당 Query를 실행할 권한이 있는지 확인한다.
- Query optimizer가 적은 비용으로 쿼리를 실행 할 수 있도록, Query의 실행계획을 짠다. 이때 DBMS의 카탈로그 정보를 참고한다.
- Query Excecutor는 Query Plan 이 나오면 실제 물리적인 자원에 어떻게 할당할 것인지 결정한다.
- 그 외에도 부가적인 처리를 할 수 있다.
- Query Parser의 동작

    ![image](https://user-images.githubusercontent.com/92377162/233919817-cf1acabd-3a2a-4e42-bcbd-a5c41a5fb3bb.png)

- 문법을 확인한다.
- 구문의 내용의 의미를 확인한다.
    - table 의 존재여부
    - column 의 존재여부
- 자원을 많이 소모하는 작업을 피하기 위한 shared pool check를 한다. 이미 있는 내용이라면, 이후 자원을 많이 소모하면서 실행계획을 짜거나 실행할 필요가 없다.
- Query Optimizer의 동작방식

    ![image](https://user-images.githubusercontent.com/92377162/233920100-bb280f36-de8e-4c70-9df1-fe6b1b3a5006.png)

- SQL의 기능은 똑같지만, SQL문의 내용의 순서나 형식 등을 바꿔서 성능상 더 나은 쿼리가 나온다면, Query Transformer에서 query를 rewrite 한다.

    ![image](https://user-images.githubusercontent.com/92377162/233920257-7c382e30-5318-4581-a47e-d9012a2263a9.png)

- Estimator 는 실행 계획에 대한 비용을 계산한다. 이때 Data dictionary를 참고한다.
    - (Oracle 의 경우)다음 지표들을 수집/계산한다.
    - Selectivity: scan한 row중에 몇 퍼센트만큼 최종결과에 선택되는지 비율을 계산한다.
    - Cardinality: 각 플랜이 리턴한 결과의 row수.
    - Cost: 해당 작업이 얼마만큼의 리소스를 사용할지예 대한 추정치. 통계를 활용하고, 통계는 지속적으로 조정된다.

#### 1-1-5. Transactional Storage Manager
- Transaction 처리와 관련된 기능들을 담당.
- 실제 데이터에 접근
- Access method는 query 실행 오퍼레이터에 의해 원본데이터에서 뽑아낸 result tuple 을 리턴한다.
- Result tuple 은 만들어지면 buffer 에 위치한다. Client Manager는 이 버퍼에서 데이터를 가져와서 응답한다.
- Transaction 의 상태 기록, 라이프사이클 관리.

#### 1-1-6. Shared Components and Utilities
- 그 외에도 시스템의 각 기능이 잘 동작하기위해서 필요한 컴포넌트나 ,유틸들이 있다.

---

## 2. MySQL Architecture

### 2-1. MySQL Basic Architecture

#### 2-1-1. Overview
- MySQL 서버의 내부 구조

    ![image](https://user-images.githubusercontent.com/92377162/233922109-88b541fa-316f-4f7f-8630-a1c0679857ef.png)

#### 2-1-2. MySQL Engine
- MySQL Engine은 클라언트로부터의 요청을 받고, SQL을 분석하고 최적화하는 역할을 수행한다.
- Connection Handler
    - 클라이언트로부터의 접속, 쿼리요청 처리
- SQL interface
    - SQL을 받아준다.
- SQL Parser
    - SQL을 파싱하고, 전처리를 한다.
- SQL Optimizer
    - 쿼리 최적화와 실행계획을 짠다.

#### 2-1-3. Storage Engine
- MySQL Storage Engine은 실제 데이터를 디스크에 저장하거나, 디스크로부터 데이터를 읽는 처리를 담당한다.
- Storage Engine 은 Plugin 방식으로 원하는 구현체를 선택할 수 있다. 즉, 하나의 DB 서버에서 논리적으로 Storage Engine을 선택할 수 있다. 선택은 database , table 마다 할 수 있다. create database, table 선언시에 `ENGINE=$ENGINE_NAME` 으로 설정한다.
- `SHOW ENGINES;` 커맨드로 확인할 수 있다.
- MySQL 은 storage engine 뿐만 아니라 다양한 기능들도 플러그인 형태로 지원한다. 인증 관련 기능, 검색용 파서, 쿼리 rewrite 플러그인 등이 있다. 기본적으로 MySQL의 표준 API 가 열려있기 때문에 가능하다.

#### 2-1-4. Handler API
- MySQL엔진의 Query Executor 가 실제 데이터를 읽거나 쓸때, Storage Engine에 요청할 때 표준인터페이스인 handler API를 통해 한다. 즉, 각 storage engine 은 구현할 때 handler API 명세를 따라 구현되어 있다. 이 표준인터페이스 때문에 플러그인 방식으로 원하는 것을 선택할 수 있다.

### 2-2. MySQL 스레드 구조

#### 2-2-1. Overview

![image](https://user-images.githubusercontent.com/92377162/233923745-f2d562af-e4f9-44b5-8acf-eb50a6244989.png)

- MySQL 은 멀티 프로세스가 아니라 멀티 스레드 기반으로 동작한다. 동작 방식에 따라 Foreground, Backgound 스레드로 구분한다. 실행중인 스레드는 performance_schema 데이터베이스 > threads 테이블에 기록된다.

#### 2-2-2. Foreground Thread(Client connection)
- foreground thread 는 최소한 현재 연결된 클라이언트의 수만큼 존재한다. 클라이언트의 커넥션이 종료되면, 다시 스레드 캐시로 돌아간다. 스레드 캐시에 일정 개수 이상의 스레드가 대기중이라면, 스레드 캐시에 돌아가지 않고, 스레드를 종료한다. 최대 대기 스레드수는 `thread_cache_size` 로 설정한다.
- foreground thread 는 데이터를 데이터 버퍼나 캐시로부터 가져오고, 버퍼나 캐시에 없다면 디스크에서 읽어서 가져온다. InnoDB는 foreground thread 는 cache, buffer 까지만 접근하고 디스크에는 접근하지 않는다. 

#### 2-2-3. Background Thread
- InnoDB 기준으로 background thread 는 다음 일을 한다.
    - insert buffer 를 merge
    - Log 를 disk에 기록
    - InnoDB buffer pool의 데이터를 disk에 기록
    - 데이터를 버퍼로 read
    - Lock monitoring thread
- 원하는 읽기 쓰기 성능이 안나오거나, 주 사용용도를 예측해서 스레드 수를 조정할 수 있다.
    - `innodb_write_io_threads`
    - `innodb_read_io_threads`
    - innodb 의 경우 읽기는 대부분 포그라운드 스레드에서 처리되기 때문에 innodb의 read 스레드를 늘릴일은 많지 않다. 쓰기 작업이 많거나, 지연되는 경우에 `innodb_write_io_threads` 를 2 이상으로 세팅한다.
- innodb는 지연된 쓰기 작업을 지원한다. 쓰기 작업을 버퍼에 넣고 아직 디스크에 쓰이기 전에 클라이언트에 응답할 수 있다. 버퍼에 쌓인것은 내부적으로 배치처리로 적용한다.

### 2-3. 메모리 구조

![image](https://user-images.githubusercontent.com/92377162/233924865-8d1bc788-730a-4bd9-9465-e385037bdb4c.png)



